/* eslint-disable @typescript-eslint/ban-ts-comment */
// Keep in mind that this file is automatically generated.

import { Prisma } from '@prisma/client';
import _ from 'lodash';
console.log(_, 'Lodash Imported'); // This should print lodash functions to the console

import {
  Aggregate,
  AnyRecord,
  BaseOption,
  CountArgs,
  Find,
  ModelName,
  ModelStructure,
  models,
  ModelScalarFields,
  ModelTypes,
  prisma,
} from './prisma-repo';

export const extractCondition = <Cursor, Where>(
  conditions: Cursor | Where | number | string,
  modelName?: keyof ModelStructure,
) => {
  const primaryKeyField = `${modelName}_id`;

  const dbCond = _.isObject(conditions)
    ? conditions
    : { [primaryKeyField]: _.toNumber(conditions) };

  return dbCond;
};

/**
 *
 * @param modelName - The model name
 * @returns the CRUD methods for each model
 */
const BaseRepository = <
  T extends ModelName,
  Where extends ModelTypes[T]['Where'],
  Select extends ModelTypes[T]['Select'],
  Include extends ModelTypes[T]['Include'],
  Create extends ModelTypes[T]['Create'],
  Update extends ModelTypes[T]['Update'],
  Cursor extends ModelTypes[T]['Cursor'],
  Order extends ModelTypes[T]['Order'],
  Delegate extends ModelTypes[T]['Delegate'],
  Scalar extends ModelScalarFields<T>,
>(
  modelName: T,
) => {
  /**
   *
   */
  abstract class AbstractBaseRepository {
    public static modelName: T = modelName;

    /**
     * 
     * @param conditions : 1.If conditions is a Where object, use it directly in the query.
                                          2.If conditions is a number, convert it into a Where object using the appropriate field (e.g., id).
                                          3.If conditions is a string, convert it into a Where object using the appropriate field (e.g., uuid or name).
     * @param filterQueryParams : Additional filtering parameters that can be passed to further refine the query results.
     * @param query : Contains pagination parameters like limit,offset page etc
     * @param option : Include, Select,Cursor, Order, Scalar and user-defined option includeDeleted?: boolean
     * @returns : All the records 
     */
    public static async findAll<
      Option extends Find<Select, Include, Cursor, Order, Scalar> & {
        includeDeleted?: boolean;
      },
      Args extends Option & { where?: Where },
      Return extends ModelTypes<Args>[T]['Return'],
    >(
      conditions: Where | number | string,
      filterQueryParams: AnyRecord = {},
      query: AnyRecord = {},
      option: Option = {} as Option,
    ) {
      const limit = +(query.limit === 'all' ? 0 : _.get(query, 'limit', 50));
      const offset =
        query.page && query.page > 0 ? limit * (query.page - 1) : 0;
      const otherOptions = _.omit(query, ['limit', 'offset', 'page']);
      const includeSoftDeleted = option.includeDeleted || false;

      console.log(modelName, 'modleName findAll');
      type WhereOrCursor = Where | Cursor;
      const where = Object.assign(
        {},
        extractCondition(conditions, modelName),
        filterQueryParams,
        otherOptions,
      );
      if (!includeSoftDeleted) {
        where.is_deleted = false;
      }
      return {
        // @ts-ignore
        rows: (await AbstractBaseRepository.model.findMany({
          // @ts-ignore
          where,
          ..._.omit(option, ['includeDeleted']), // Remove includeDeleted from options
          skip: offset,
          ...(limit > 0 && { take: limit }),
        })) as Return[],
        /* @ts-ignore */
        count: await this.count(where),
      };
    }

    public static async findMany(...params: Parameters<typeof this.findAll>) {
      return AbstractBaseRepository.findAll(...params);
    }

    /**
     * Find the first `model` that matches the filter.\
     * Note, that providing `undefined` is treated as the value not being there.
     * 
     *
     * 
     * @param conditions : 1.If conditions is a Where object, use it directly in the query.
                                          2.If conditions is a number, convert it into a Where object using the appropriate field (e.g., id).
                                          3.If conditions is a string, convert it into a Where object using the appropriate field (e.g., uuid or name).
     * @param filterQueryParams : Additional filtering parameters that can be passed to further refine the query results.
     * @param query : Contains pagination parameters like limit,offset page etc
     * @param option : Include, Select,Cursor, Order, Scalar and user-defined option includeDeleted?: boolean
     * @returns : One matching record
     */

    public static async findOne<
      Option extends Find<Select, Include, Cursor, Order, Scalar> & {
        includeDeleted?: boolean;
      },
      Args extends Option & { where?: Where },
      Return extends ModelTypes<Args>[T]['Return'],
    >(conditions: Where | number | string, option: Option = {} as Option) {
      const where = Object.assign({}, extractCondition(conditions, modelName));
      const includeSoftDeleted = option.includeDeleted || false;

      if (!includeSoftDeleted) {
        (where as Record<string, any>).is_deleted = false;
      }

      // @ts-ignore
      return AbstractBaseRepository.model.findFirst({
        // @ts-ignore
        where,
        ..._.omit(option, ['includeDeleted']), // Remove includeDeleted from options
      }) as Promise<Return | null>;
    }

    /**
     * Alternative of `findOne`.\
     * It works same as `findOne` but only have different names.\
     * It exists for anyone who prefer to use prisma `functions` original name.
     */
    public static async findFirst(...params: Parameters<typeof this.findOne>) {
      return AbstractBaseRepository.findOne(...params);
    }

    /**
     * Find zero or one `model` that matches the filter.\
     * Note, that providing `undefined` is treated as the value not being there.\
     * It works same as `findOne` or `findFirst` but only accept a unique column.
     * 
     *  @param conditions : 1.If conditions is a Where object, use it directly in the query.
                                          2.If conditions is a number, convert it into a Where object using the appropriate field (e.g., id).
                                          3.If conditions is a string, convert it into a Where object using the appropriate field (e.g., uuid or name).
     * @param filterQueryParams : Additional filtering parameters that can be passed to further refine the query results.
     * @param query : Contains pagination parameters like limit,offset page etc
     * @param option : Include, Select,Cursor, Order, Scalar and user-defined option includeDeleted?: boolean
     * @returns : One unique record
     */

    // base-repo.ts
    public static async findUnique<
      Option extends BaseOption<Include, Select> & { includeDeleted?: boolean },
      Args extends Option & { where?: Cursor },
      Return extends ModelTypes<Args>[T]['Return'],
    >(conditions: Cursor, option: Option = {} as Option) {
      const where = extractCondition(conditions, modelName);
      const includeSoftDeleted = option.includeDeleted || false;

      if (!includeSoftDeleted) {
        (where as Record<string, any>).is_deleted = false;
      }

      // @ts-ignore
      return AbstractBaseRepository.model.findUnique({
        // @ts-ignore
        where,
        ..._.omit(option, ['includeDeleted']), // Remove includeDeleted from options
      }) as Promise<Return | null>;
    }

    /**
     * Create a `model`.
     *
     */
    /**
     *
     * @param data : payload to be sent , of type CreateStateDTO
     * @param option
     * @returns Newly created record
     */
    public static async create<
      Option extends BaseOption<Include, Select>,
      Args extends Option & { data: Create },
      Return extends ModelTypes<Args>[T]['Return'],
    >(data: Create, option: Option = {} as Option) {
      // @ts-ignore
      return AbstractBaseRepository.model.create({
        data,
        ...option,
      }) as Promise<Return | null>;
    }

    /**
     * Update a `model`.
     */
    /**
 * 
 * @param conditions :     1.If conditions is a Where object, use it directly in the query.
                                          2.If conditions is a number, convert it into a Where object using the appropriate field (e.g., id).
                                          3.If conditions is a string, convert it into a Where object using the appropriate field (e.g., uuid or name).
 * @param data :payload to be sent , of type UpdateStateDTO
 * @param option:Include, Select,Cursor, Order, Scalar and user-defined option includeDeleted?: boolean
 * @returns  Updated record
 */
    public static async update<
      Option extends BaseOption<Include, Select>,
      Payload extends Update | Create,
      Args extends Option & { data: Payload },
      Return extends ModelTypes<Args>[T]['Return'],
    >(
      conditions: Where | number | string,
      data: Payload,
      option: Option = {} as Option,
    ) {
      const where = extractCondition(conditions, modelName);

      // @ts-ignore
      return AbstractBaseRepository.model.update({
        data,
        // @ts-ignore
        where,
        ...option,
      }) as Promise<Return>;
    }
    /**
 * 
 * @param modelName : Name of the module
 * @param conditions :1.If conditions is a Where object, use it directly in the query.
                                          2.If conditions is a number, convert it into a Where object using the appropriate field (e.g., id).
                                          3.If conditions is a string, convert it into a Where object using the appropriate field (e.g., uuid or name).
 * @param additionalData : modified by , modified on etc
 * @param option 
 * @returns statuscode, message .
 */
    public static async softDelete<
      Option extends BaseOption<Include, Select>,
      Payload extends Update,
      Args extends Option & { data: Payload },
      Return extends ModelTypes<Args>[T]['Return'],
      Include = any,
      Select = any,
    >(
      modelName: ModelName,
      conditions: Where | number | string,
      additionalData: Partial<Payload> = {},
      option: Option = {} as Option,
    ): Promise<Return> {
      const where = extractCondition(conditions, modelName);

      // Dynamically build the update data based on the model's fields
      const updateData: {
        is_deleted: true;
        modified_on?: Date;
        modified_by?: string;
      } = {
        is_deleted: true,
      };

      if ('modified_on' in additionalData) {
        updateData.modified_on = new Date();
      }

      if (
        'modified_by' in additionalData &&
        typeof additionalData.modified_by === 'string'
      ) {
        updateData.modified_by = additionalData.modified_by;
      }

      // Access the model dynamically
      const model = models[modelName];
      if (!model) {
        throw new Error(`Model ${modelName} not found in models object`);
      }

      return model.update({
        data: { ...updateData, ...additionalData },
        where,
        ...option,
      }) as Promise<Return>;
    }

    /**
     * Delete any `model` that match with the conditions.
     */
    /**
 * 
 * @param conditions :1.If conditions is a Where object, use it directly in the query.
                                          2.If conditions is a number, convert it into a Where object using the appropriate field (e.g., id).
                                          3.If conditions is a string, convert it into a Where object using the appropriate field (e.g., uuid or name).
 * @returns statusCode, success flag
 */
    public static async delete(conditions: Where | number | string) {
      const where = extractCondition(conditions, modelName);

      // @ts-ignore
      return AbstractBaseRepository.model.deleteMany({
        // @ts-ignore
        where,
      }) as Promise<Prisma.BatchPayload>;
    }

    /**
     * Delete a `model`.
     */

    public static async deleteOne<
      Option extends { select?: Select },
      Return extends ModelTypes<Option>[T]['Return'],
    >(conditions: Where | number | string, options: Option = {} as Option) {
      const where = extractCondition(conditions, modelName);

      // @ts-ignore
      return AbstractBaseRepository.model.delete({
        // @ts-ignore
        where,
        ...options,
      }) as Promise<Return>;
    }

    /**
     * Create or update one `model`.
     */

    /**
     * Create many `model`.
     */
    public static async bulkCreate(
      data: Prisma.Enumerable<Create>,
      skipDuplicates = true,
    ) {
      // @ts-ignore
      return AbstractBaseRepository.model.createMany({
        data,
        // @ts-ignore
        skipDuplicates,
      }) as Promise<Prisma.BatchPayload>;
    }

    /**
     * Alternative of `bulkCreate`.\
     * It works same as `bulkCreate` but only have different names.\
     * It exists for anyone who prefer to use prisma `functions` original name.
     */
    public static async createMany(
      ...params: Parameters<typeof this.bulkCreate>
    ) {
      return AbstractBaseRepository.bulkCreate(...params);
    }

    /**
     * Update zero or more `model`.
     * Note, that providing `undefined` is treated as the value not being there.
     */

    public static async bulkUpdate(
      where: Where,
      data: Prisma.Enumerable<Update>,
    ) {
      // @ts-ignore
      return AbstractBaseRepository.model.updateMany({
        data,
        where,
      }) as Promise<Prisma.BatchPayload>;
    }

    /**
     * Alternative of `bulkUpdate`.\
     * It works same as `bulkUpdate` but only have different names.\
     * It exists for anyone who prefer to use prisma `functions` original name.
     */
    public static async updateMany(
      ...params: Parameters<typeof this.bulkUpdate>
    ) {
      return AbstractBaseRepository.bulkUpdate(...params);
    }

    /**
     * Count the number of `model`.\
     * Note, that providing `undefined` is treated as the value not being there.
     */

    public static async count(
      conditions: Where | number | string,
      option: CountArgs<Select, Cursor, Order, Scalar> = {},
    ) {
      const where = extractCondition(conditions, modelName);

      // @ts-ignore
      return AbstractBaseRepository.model.count({
        // @ts-ignore
        where,
        ...option,
      }) as Promise<number>;
    }

    public static async groupBy(
      conditions: Where | number | string,
      aggregator: Omit<
        // @ts-ignore
        Parameters<typeof this.model.aggregate>[0],
        'where' | 'cursor'
      > & {
        groupBy: Scalar[];
      },
    ) {
      const where = extractCondition(conditions, modelName);

      // @ts-ignore
      return AbstractBaseRepository.model.groupBy({
        // @ts-ignore
        where,
        ...aggregator,
      });
    }

    /**
     * Allows you to perform aggregations operations on a `model`.\
     * Note, that providing `undefined` is treated as the value not being there.\
     * If no any kind of aggregator provided, will use `count` by default.
     */

    public static aggregate(
      conditions: Where | number | string,
      aggregator: Omit<
        // @ts-ignore
        Parameters<typeof this.model.aggregate>[0],
        'cursor' | 'take' | 'skip' | 'orderBy' | 'where'
      >,
      option: Aggregate<Cursor, Order, Scalar> = {},
    ) {
      // @ts-ignore
      const aggregate = AbstractBaseRepository.model
        .aggregate as Delegate['aggregate'];
      const where = extractCondition(conditions, modelName);

      if (_.isEmpty(aggregator)) {
        // @ts-ignore
        // eslint-disable-next-line no-param-reassign, no-underscore-dangle
        aggregator._count = true;
      }

      // @ts-ignore
      return aggregate({
        // @ts-ignore
        where,
        ...aggregator,
        ...option,
      }) as ReturnType<typeof aggregate>;
    }

    public static get model(): Delegate {
      // @ts-ignore
      return models[AbstractBaseRepository.modelName];
    }
  }

  return AbstractBaseRepository;
};

export default BaseRepository;
